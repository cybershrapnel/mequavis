<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MEQUAVIS UI</title>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
  }
}
</script>


<script src="https://cdn.tailwindcss.com"></script>
<style>
  body { background:black; color:white; font-family:monospace; overflow:hidden; }
/* Base canvas styling */
canvas {
  display: block;
  margin: auto;
}

/* Only the main Mequavis canvas is fixed and centered */
#mequavis {
  position: fixed;
  top: 50%;
  left: 50%;
  transform-origin: center center;
}

/* === Global MEQUAVIS Scrollbar Theme === */

/* Colors */
:root {
  --scroll-track: #050505;       /* dark panel background */
  --scroll-thumb: #0ff;          /* cyan like borders/buttons */
  --scroll-thumb-hover: #9ff;    /* lighter cyan on hover */
}

/* Firefox */
* {
  scrollbar-width: thin;
  scrollbar-color: var(--scroll-thumb) var(--scroll-track);
}

/* WebKit (Chrome, Edge, etc.) */
*::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

*::-webkit-scrollbar-track {
  background: var(--scroll-track);
}

*::-webkit-scrollbar-thumb {
  background: var(--scroll-thumb);
  border-radius: 4px;
  border: 1px solid #033;          /* subtle deep blue border */
  box-shadow: 0 0 4px #033 inset;  /* slight inner glow */
}

*::-webkit-scrollbar-thumb:hover {
  background: var(--scroll-thumb-hover);
}



  #layoutBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 999;
    background: #111;
    color: #0ff;
    border: 2px solid #0ff;
    padding: 6px 14px;
    border-radius: 6px;
    cursor: pointer;
    font-family: monospace;
  }
#segmentLog {
  position: fixed;
  left: 10px;
  top: 60px;
  width: 260px;
  /* height: 780px;  <-- remove this */
  height: calc(100vh - 70px); /* 100vh minus top (60) and a bit of bottom margin */
  background: #050505;
  border: 1px solid #0ff;
  padding: 8px;
  font-family: monospace;
  font-size: 11px;
  color: #0ff;
  overflow-y: auto;
  z-index: 998;
}

#segmentLog h2 {
  font-size: 12px;
  margin-bottom: 4px;
  color: #0ff;
}
#segmentLog .entry {
  border-bottom: 1px solid #222;
  padding: 2px 0;
}
#rightPanel {
  position: fixed;
  right: 10px;
  top: 60px;
  width: 260px;
  /* height: 780px; <-- remove this */
  height: calc(100vh - 70px); /* same logic as left panel */
  background: #050505;
  border: 1px solid #0ff;
  padding: 8px;
  font-family: monospace;
  font-size: 11px;
  color: #0ff;
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 998;
}


/* Top section: big buttons */
#rightTop {
  flex: 0 0 30%;
}

.action-btn {
  width: 100%;
  margin-bottom: 6px;
  padding: 10px 4px;
  border: 1px solid #0ff;
  background: #111;
  color: #0ff;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-weight: bold;
  text-align: center;
}
.action-btn:hover {
  background: #033;
}

/* Middle section: AI output */
#rightMiddle {
  flex: 1 1 auto;
  border: 1px solid #222;
  padding: 4px;
  overflow-y: auto;
  background: #000;
}

#aiOutput .msg {
  margin-bottom: 4px;
}
#aiOutput .sender {
  color: #0f0;
  font-weight: bold;
}

/* Bottom section: input + send */
#rightBottom {
  flex: 0 0 auto;
  border-top: 1px solid #222;
  padding-top: 4px;
}

#aiInput {
  width: 100%;
  box-sizing: border-box;
  background: #000;
  border: 1px solid #0ff;
  color: #0ff;
  font-family: monospace;
  font-size: 11px;
  padding: 4px;
  resize: none;
  height: 50px;
}

#aiSend {
  margin-top: 4px;
  width: 100%;
  padding: 6px 4px;
  background: #0ff;
  color: #000;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  cursor: pointer;
}
#aiSend:hover {
  background: #9ff;
}


</style>
</head>
<body>
<button id="layoutBtn">Layout</button>



<!-- RIGHT CONTROL / CHAT PANEL -->
<div id="rightPanel">
  <!-- Top: big action buttons -->
  <div id="rightTop">
<button class="action-btn" data-action="mandelbrot-zoom">View Mandelbrot Zoom Location</button>
    <button class="action-btn" data-action="watch-tv">WATCH AI CABLETV</button>
    <button class="action-btn" data-action="show-map">SHOW MAP UI</button>
    <button class="action-btn" data-action="open-tools">OPEN TOOLKIT</button>
    <button class="action-btn" data-action="other-mode">OTHER MODE</button>
  <button class="action-btn" data-action="full-chat">FULL CHAT MODE</button>
  </div>

  <!-- Middle: AI output / chat log -->
  <div id="rightMiddle">
    <div id="aiOutput"></div>
  </div>

  <!-- Bottom: input box + send -->
  <div id="rightBottom">
  <!-- NEW: model dropdown row -->
  <div id="modelRow" style="margin-bottom:4px;font-size:11px;">
    <label>
      Model:
      <select id="modelSelect"
              style="background:#000;border:1px solid #0ff;color:#0ff;font-family:monospace;font-size:11px;">
 <option value="gemini:gemini-2.0-flash" selected>Gemini 2.0 Flash</option>
        <option value="openai:gpt-4.1-mini">OpenAI: gpt-4.1-mini</option>
        <option value="openai:gpt-4.1">OpenAI: gpt-4.1 (alternate)</option>
        <option value="anthropic:claude-3.5-sonnet">Claude 3.5 Sonnet (stub)</option>
        <option value="dummy:local">Local / Other (stub)</option>
      </select>
    </label>
  </div>
    <textarea id="aiInput" placeholder="Type a prompt..."></textarea>
    <button id="aiSend">SEND</button>
  </div>
</div>






<!-- Segment log panel -->
<div id="segmentLog"></div>




<!-- MANDELBROT PANEL (hidden by default) -->
<div id="mandelPanel" style="
  display:none;
  position:fixed;
  left:280px;
  right:280px;
  top:70px;
  bottom:20px;
  background:#000;
  border:1px solid #0ff;
  z-index:999;
  padding:8px;
  box-sizing:border-box;
">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
    <span style="color:#0ff; font-family:monospace; font-size:12px;">
      MANDELBROT ZOOM • driven by Segment Addresses
    </span>
    <button id="mandelClose" style="
      background:#111;
      color:#0ff;
      border:1px solid #0ff;
      font-family:monospace;
      font-size:11px;
      padding:2px 8px;
      cursor:pointer;
    ">CLOSE</button>
  </div>
  <canvas id="mandelCanvas" width="800" height="800" style="width:100%; height:calc(100% - 24px); background:#000;"></canvas>
</div>





<canvas id="mequavis" width="1600" height="900"></canvas>

<script>


// ===== RIGHT PANEL: SIMPLE CHAT / CONTROL WIRES =====
const aiOutputEl = document.getElementById("aiOutput");
const aiInputEl  = document.getElementById("aiInput");
const aiSendBtn  = document.getElementById("aiSend");

// --- 30s cooldown state for AI send button ---
const AI_SEND_COOLDOWN_SECONDS = 30;
let aiSendCooldown            = false;
let aiSendCooldownTimer       = null;
let aiSendCooldownRemaining   = 0;

// Start / manage the cooldown on the SEND button
function startAiSendCooldown() {
  if (!aiSendBtn) return;

  // Save original label once
  if (!aiSendBtn.dataset.originalLabel) {
    aiSendBtn.dataset.originalLabel = aiSendBtn.textContent || aiSendBtn.value || "SEND";
  }

  // Reset any existing timer
  if (aiSendCooldownTimer) {
    clearInterval(aiSendCooldownTimer);
    aiSendCooldownTimer = null;
  }

  aiSendCooldown          = true;
  aiSendCooldownRemaining = AI_SEND_COOLDOWN_SECONDS;
  aiSendBtn.disabled      = true;

  const setLabel = (txt) => {
    if ("textContent" in aiSendBtn) {
      aiSendBtn.textContent = txt;
    } else if ("value" in aiSendBtn) {
      aiSendBtn.value = txt;
    }
  };

  setLabel(`WAIT ${aiSendCooldownRemaining}s`);

  aiSendCooldownTimer = setInterval(() => {
    aiSendCooldownRemaining--;

    if (aiSendCooldownRemaining <= 0) {
      clearInterval(aiSendCooldownTimer);
      aiSendCooldownTimer = null;
      aiSendCooldown      = false;
      aiSendBtn.disabled  = false;

      const original = aiSendBtn.dataset.originalLabel || "SEND";
      setLabel(original);
    } else {
      setLabel(`WAIT ${aiSendCooldownRemaining}s`);
    }
  }, 1000);
}

// Helper to append messages to the middle log
function appendAIMessage(sender, text) {
  if (!aiOutputEl) return;
  const div = document.createElement("div");
  div.className = "msg";
  div.innerHTML = `<span class="sender">${sender}:</span> ${text}`;
  aiOutputEl.appendChild(div);
  aiOutputEl.scrollTop = aiOutputEl.scrollHeight;
}

// Handle sending input
function handleSend() {
  if (!aiInputEl) return;

  // Block sends while cooldown is active
  if (aiSendCooldown) return;

  const text = aiInputEl.value.trim();
  if (!text) return;

  // Show user message in the log
  appendAIMessage("User Query", text);

  // Clear box
  aiInputEl.value = "";

  // Kick off the 30s cooldown
  startAiSendCooldown();

  // Hand off to external chat module (meq-chat.js)
  if (window.MeqChat && typeof window.MeqChat.send === "function") {
    window.MeqChat.send(text);
  } else {
    // Fallback if external JS isn't loaded yet
    appendAIMessage("AI", "(chat backend not ready)");
  }
}

// Wire up send button + Enter key
if (aiSendBtn) {
  aiSendBtn.addEventListener("click", handleSend);
}
if (aiInputEl) {
  aiInputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend(); // this will no-op if cooldown is active
    }
  });
}

// Wire up the big top buttons to log into the middle panel
document.querySelectorAll(".action-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    const label  = btn.textContent.trim();
    const action = btn.dataset.action || "unknown";
    appendAIMessage("System", `[${label}] clicked (action = ${action})`);

    if (action === "mandelbrot-zoom") {
      showMandelPanel();
    }
    // later you can switch(action) { ... } to trigger real UI modes
  });
});





const canvas = document.getElementById("mequavis");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

const BASE_W = W;
const BASE_H = H;

function updateCanvasScale() {
  const leftPanel  = document.getElementById("segmentLog"); // or your left panel ID
  const rightPanel = document.getElementById("rightPanel"); // your right panel ID

  const leftWidth  = leftPanel  ? leftPanel.offsetWidth  + 20 : 0; // + some margin
  const rightWidth = rightPanel ? rightPanel.offsetWidth + 20 : 0;

  const availableWidth  = window.innerWidth;
  const availableHeight = window.innerHeight - 40; // leave some top/bottom margin

  // scale so the whole 1600x900 fits inside available area, but don't upscale above 1
  const scale = Math.min(
    availableWidth  / BASE_W,
    availableHeight / BASE_H,
    1
  );

  canvas.style.transform = `translate(-50%, -50%) scale(${scale})`;
}

// run once and on resize
updateCanvasScale();
window.addEventListener("resize", updateCanvasScale);



const center = {x: W/2, y: H/2};
let compact = false;

//let nofurs = [];            // list of nofurs for click hits
window.nofurs = [];
let nofurs = window.nofurs; // keep the rest of your code using "nofurs"

let seekerPositions = [];   // seeker nodes for omega-linking
let omniverseAddress = "";  // accumulated address string, grows by 1 digit per click

// Add this near your global variables:
let segment = 1;
let segmentHistory = [];





// === MANDELBROT STATE ===
let mandelPanel   = null;
let mandelCanvas  = null;
let mandelCtx     = null;
let mandelCenterX = -0.75;   // standard Mandelbrot center
let mandelCenterY = 0.0;
let mandelScale   = 3.0;     // width of the visible region in the complex plane
let mandelZoomLevel = 0;
let mandelInitialized = false;

// Initialize references once
function initMandel() {
  if (mandelInitialized) return;
  mandelPanel  = document.getElementById("mandelPanel");
  mandelCanvas = document.getElementById("mandelCanvas");
  mandelCtx    = mandelCanvas.getContext("2d");

  const closeBtn = document.getElementById("mandelClose");
  if (closeBtn && mandelPanel) {
    closeBtn.addEventListener("click", () => {
      mandelPanel.style.display = "none";
    });
  }

  mandelInitialized = true;
}

// Show panel + redraw current view
function showMandelPanel() {
  initMandel();
  if (!mandelPanel) return;
  mandelPanel.style.display = "block";
  drawMandelbrot();
}

// Map an address string → complex plane center.
// We treat the address as digits, split into X and Y parts, normalize to [0,1],
// then map to the usual Mandelbrot window.
function addressToComplex(addressStr) {
  const digits = (addressStr || "0").replace(/\D/g, "");
  const padded = digits.padStart(16, "0").slice(0, 16); // 16 digits
  const half   = 8;
  const xStr   = padded.slice(0, half);
  const yStr   = padded.slice(half);

  const maxX = Math.pow(10, half) - 1;
  const maxY = maxX;

  const xVal = parseInt(xStr, 10) || 0;
  const yVal = parseInt(yStr, 10) || 0;

  const nx = xVal / maxX; // 0..1
  const ny = yVal / maxY; // 0..1

  // Map to Mandelbrot base ranges:
  // real in [-2, 1], imag in [-1.5, 1.5]
  const cx = -2 + nx * 3;   // -2 → 1
  const cy = -1.5 + ny * 3; // -1.5 → 1.5

  return { cx, cy };
}

// Draw Mandelbrot at (mandelCenterX, mandelCenterY, mandelScale)
function drawMandelbrot() {
  if (!mandelCanvas || !mandelCtx) return;
  const w = mandelCanvas.width;
  const h = mandelCanvas.height;
  const img = mandelCtx.createImageData(w, h);
  const data = img.data;

  const maxIter = 100 + mandelZoomLevel * 10; // more iterations as we zoom

  for (let py = 0; py < h; py++) {
    for (let px = 0; px < w; px++) {
      // Map pixel -> complex plane
      const x0 = mandelCenterX + (px - w / 2) * (mandelScale / w);
      const y0 = mandelCenterY + (py - h / 2) * (mandelScale / h);

      let x = 0, y = 0;
      let iter = 0;
      while (x*x + y*y <= 4 && iter < maxIter) {
        const xTemp = x*x - y*y + x0;
        y = 2*x*y + y0;
        x = xTemp;
        iter++;
      }

      const idx = (py * w + px) * 4;
      if (iter === maxIter) {
        // In the set: black
        data[idx]   = 0;
        data[idx+1] = 0;
        data[idx+2] = 0;
      } else {
        // Simple coloring based on iteration
        const shade = Math.floor(255 * iter / maxIter);
        data[idx]   = shade;
        data[idx+1] = (shade * 2) % 255;
        data[idx+2] = (shade * 3) % 255;
      }
      data[idx+3] = 255;
    }
  }

  mandelCtx.putImageData(img, 0, 0);
}

// Called when a segment finishes (wrap of layers).
// Uses the full omniverse address to choose a new center and zooms in more.
function mandelbrotZoomStep(fullAddress) {
  initMandel();

  // Choose a new center based on the finished segment address
  const { cx, cy } = addressToComplex(fullAddress);
  mandelCenterX = cx;
  mandelCenterY = cy;

  // Zoom in (each segment halves the visible window)
  mandelZoomLevel++;
  mandelScale = 3.0 * Math.pow(0.5, mandelZoomLevel);

  drawMandelbrot();
}







// Gasket indexing
let gasket = 1;
let gasketPower = 1;
const GASKET_MAX = 17; // gasket goes 1..18 then wraps

// Render the segment history into the left panel
// Render the segment history into the left panel without nuking other children
function updateSegmentLog() {
  const panel = document.getElementById("segmentLog");
  if (!panel) return;

  // Create header + list container once and then reuse them
  let header = panel.querySelector("h2.segment-header");
  let list   = panel.querySelector(".segment-list");

  if (!header) {
    header = document.createElement("h2");
    header.className = "segment-header";
    header.textContent = "Segments";
    panel.appendChild(header);
  }

  if (!list) {
    list = document.createElement("div");
    list.className = "segment-list";
    panel.appendChild(list);
  }

  // Now only touch the list's innerHTML, not the whole panel
  if (segmentHistory.length === 0) {
    list.innerHTML = `<div class="entry">No segments yet</div>`;
    return;
  }

  list.innerHTML = segmentHistory.map(entry =>
    `<div class="entry">
       Gasket ${entry.gasket}<sup>${entry.power}</sup>,
       Seg ${entry.segment}: ${entry.address}
     </div>`
  ).join("");
}



// Initialize empty panel once
updateSegmentLog();



// === CLICK HANDLER ===
canvas.addEventListener("click", e => {
const rect = canvas.getBoundingClientRect();

// map from scaled pixels → original 1600x900 coordinates
const scaleX = canvas.width  / rect.width;
const scaleY = canvas.height / rect.height;

const mouseX = (e.clientX - rect.left) * scaleX;
const mouseY = (e.clientY - rect.top)  * scaleY;


  for (const n of nofurs) {
    if (!n.flag || (n.flag !== "left" && n.flag !== "right")) continue;

    const dx = mouseX - n.center.x;
    const dy = mouseY - n.center.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

if (dist < n.outerRadius + 10) {

  // --- Layer decrement with wrap ---
  // --- Layer decrement with wrap ---
  if (activeLayers > 1) {
    activeLayers--;
  } else {
    // We are about to wrap: store the finished segment first
    const fullAddress = (omniverseAddress === "" ? "0" : omniverseAddress);


    // NEW: drive Mandelbrot zoom from this finished segment
    mandelbrotZoomStep(fullAddress);


    segmentHistory.push({
      gasket: gasket,
      power: gasketPower,
      segment: segment,
      address: fullAddress
    });
    updateSegmentLog();     // refresh left panel

    // Increment segment, reset layers and address
    segment++;
    if (segment > pyramidLayers) {
      // finished a full 1..17 sweep of the gasket
      segment = 1;
      gasket++;
      if (gasket > GASKET_MAX) {
        gasket = 1;
        gasketPower++; // increment the "multiplier" / exponent
      }
    }

    activeLayers = pyramidLayers;
    omniverseAddress = "";
  }


  // --- Append 1 digit (baseDigit) to address for this click ---
  if (typeof n.baseDigit === "number") {
    const digit = String(n.baseDigit);
    omniverseAddress += digit;

    if (n.address !== undefined) {
      n.address += digit;
    }
  }

  break;
}

  }
});


const nodeColors = {
  1:"#ff0000",12:"#ff0000",
  2:"#ffff00",11:"#ffff00",
  3:"#00ffff",10:"#00ffff",
  4:"#ff00ff",9:"#ff00ff",
  5:"#00ff00",8:"#00ff00",
  6:"#00008B",7:"#00008B",
  13:"#8888ff"
};

const outerOrder = [12,1,2,11,10,3,4,9,5,8,7,6];
const innerPairs = [
  [12,1],[2,11],[10,3],[4,9],[5,8],[6,7]
];

function drawNode(x,y,num,colorOverride=null){
  const color = colorOverride||nodeColors[num]||"#999";
  ctx.beginPath();
  ctx.arc(x,y,10,0,Math.PI*2);
  ctx.fillStyle=color;
  ctx.fill();
  ctx.lineWidth=1;
  ctx.strokeStyle="#333";
  ctx.stroke();
  ctx.fillStyle="#000";
  ctx.font="13px monospace";
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(num,x,y);
}

// Custom seeker angle offsets (in radians)
const seekerAngles = {
  ALPHA: [Math.PI * 0.20],
  BETA: [Math.PI * 0.80],
  DELTA: [Math.PI * 1.85],
  GAMMA: [Math.PI * 1.15],
  OMEGA: [
    Math.PI * 0.75,
    Math.PI * 0.25,
    Math.PI * 1.25,
    Math.PI * 1.75
  ]
};

function drawNofur(baseX, baseY, label, rotation = 0, scale = 1, spinInner = true, isLeft = false, isRight = false) {
  ctx.save();
  ctx.translate(baseX, baseY);
  ctx.scale(scale, scale);

  const radiusOuter = 100;
  const radiusInner = 50;

  // === Outer ring ===
  let outerCoords = [];
  for (let i = 0; i < outerOrder.length; i++) {
    const angle = (i / outerOrder.length) * Math.PI * 2 - Math.PI / 2 + rotation;
    const x = Math.cos(angle) * radiusOuter;
    const y = Math.sin(angle) * radiusOuter;
    outerCoords.push({ x, y, num: outerOrder[i] });
  }

  // === Inner ring ===
  let innerCoords = [];
  const innerRot = spinInner ? rotation : 0;
  for (let i = 0; i < innerPairs.length; i++) {
    const aIndex = outerOrder.indexOf(innerPairs[i][0]);
    const bIndex = outerOrder.indexOf(innerPairs[i][1]);
    const angleA = (aIndex / outerOrder.length) * Math.PI * 2 - Math.PI / 2 + innerRot;
    const angleB = (bIndex / outerOrder.length) * Math.PI * 2 - Math.PI / 2 + innerRot;
    const midAngle = (angleA + angleB) / 2;
    const x = Math.cos(midAngle) * radiusInner;
    const y = Math.sin(midAngle) * radiusInner;
    innerCoords.push({ x, y, num: 14 + i });
  }

  drawNode(0, 0, 13, nodeColors[13]);

  ctx.lineWidth = 1;
  ctx.strokeStyle = "#888";
  for (let i = 0; i < innerCoords.length; i++) {
    const inner = innerCoords[i];
    const [a, b] = innerPairs[i];
    const leftOuter = outerCoords.find(o => o.num === a);
    const rightOuter = outerCoords.find(o => o.num === b);
    if (leftOuter && rightOuter) {
      ctx.beginPath();
      ctx.moveTo(inner.x, inner.y);
      ctx.lineTo(leftOuter.x, leftOuter.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(inner.x, inner.y);
      ctx.lineTo(rightOuter.x, rightOuter.y);
      ctx.stroke();
    }
  }

  if (!isLeft && !isRight) {
    for (let i = 0; i < innerCoords.length; i++) {
      for (let j = i + 1; j < innerCoords.length; j++) {
        const a = innerCoords[i];
        const b = innerCoords[j];
        const aOdd = a.num % 2 !== 0;
        const bOdd = b.num % 2 !== 0;

        if (aOdd && bOdd) {
          ctx.strokeStyle = "#FF00FF";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        } else if (!aOdd && !bOdd) {
          ctx.strokeStyle = "#FF0000";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }
  }

  ctx.strokeStyle = "#001F3F";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.stroke();

  ctx.strokeStyle = "#555";
  ctx.beginPath(); ctx.arc(0, 0, radiusInner + 10, 0, Math.PI * 2); ctx.stroke();

  ctx.strokeStyle = "#FFA500";
  ctx.beginPath(); ctx.arc(0, 0, radiusOuter + 10, 0, Math.PI * 2); ctx.stroke();

  for (let n of outerCoords) drawNode(n.x, n.y, n.num);
  for (let i = 0; i < innerCoords.length; i++) {
    const n = innerCoords[i];
    const color = (i % 2 === 0) ? "#444444" : "#BBBBBB";
    drawNode(n.x, n.y, n.num, color);
  }

  ctx.restore();

  ctx.fillStyle = "white";
  ctx.font = "16px monospace";
  ctx.textAlign = "center";
  if (!isLeft && !isRight && (label === "ALPHA" || label === "BETA")) {
    ctx.fillText(label, baseX, baseY - radiusOuter * scale - 25);
  } else {
    ctx.fillText(label, baseX, baseY + radiusOuter * scale + 25);
  }

  // === Dynamic seeker node(s) ===
  if (!isLeft && !isRight) {
    const globalOuter = outerCoords.map(o => ({
      gx: baseX + o.x * scale,
      gy: baseY + o.y * scale,
      num: o.num
    }));

    // Helper to draw seeker + line
    function drawSeeker(angleOffset) {
      const seekerRadius = (radiusOuter + 45) * scale;
      const seekerX = baseX + Math.cos(angleOffset) * seekerRadius;
      const seekerY = baseY + Math.sin(angleOffset) * seekerRadius;

      let nearest = null;
      let nearestDist = Infinity;
      for (let o of globalOuter) {
        const dx = seekerX - o.gx;
        const dy = seekerY - o.gy;
        const d2 = dx * dx + dy * dy;
        if (d2 < nearestDist) {
          nearestDist = d2;
          nearest = o;
        }
      }

      const matchColor = nearest ? nodeColors[nearest.num] || "#ffffff" : "#ffffff";

      if (nearest) {
        ctx.strokeStyle = matchColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(seekerX, seekerY);
        ctx.lineTo(nearest.gx, nearest.gy);
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.arc(seekerX, seekerY, 8, 0, Math.PI * 2);
      ctx.fillStyle = matchColor;
      ctx.fill();
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 1;
      ctx.stroke();

      // record seeker for omega-connection pass
      seekerPositions.push({ label, x: seekerX, y: seekerY, color: matchColor });
    }

    // Single or multiple seekers
    const angles = seekerAngles[label] || [Math.PI * 3 / 4];
    for (let ang of angles) drawSeeker(ang);
  }
}

const baseOffsets = [
  {id:"ALPHA",x:-300,y:-250},
  {id:"BETA", x:300,y:-250},
  {id:"DELTA",x:-300,y:250},
  {id:"GAMMA",x:300,y:250},
  {id:"OMEGA",x:0,y:0}
];

// helper: format small labels using base digit + full omniverse address
function formatSmallLabel(n) {
  return "L2-O" + n.address;
}


function drawOmniverse(baseX,baseY,rot,scale=1,isSmall=false,isLeft=false,isRight=false){
  for(let nf of baseOffsets){
    let shrinkFactor = (compact && isSmall && nf.id!=="OMEGA") ? 0.5 : 1.0;
    let dx = nf.x * scale * shrinkFactor;
    let dy = nf.y * scale * shrinkFactor;

    let label = nf.id;
    let baseDigit = null; // for side L2-ON labels

    if(isSmall && isLeft){
      if(nf.id==="ALPHA") baseDigit = 2;
      if(nf.id==="BETA")  baseDigit = 3;
      if(nf.id==="DELTA") baseDigit = 6;
      if(nf.id==="GAMMA") baseDigit = 7;
      if(nf.id==="OMEGA") baseDigit = 0;
    }
    if(isSmall && isRight){
      if(nf.id==="ALPHA") baseDigit = 4;
      if(nf.id==="BETA")  baseDigit = 5;
      if(nf.id==="DELTA") baseDigit = 8;
      if(nf.id==="GAMMA") baseDigit = 9;
      if(nf.id==="OMEGA") baseDigit = 1;
    }
let addressStr = "";  // local address we will display/use

if (isSmall && baseDigit !== null) {
  const currentLayer = (pyramidLayers - activeLayers) + 1;
  const displayLayer = currentLayer + 1;

  // ✅ keep left/right addresses separate on the shared baseOffsets objects
  const key = isLeft ? "leftAddress" : (isRight ? "rightAddress" : null);

  if (key) {
    if (!nf[key]) nf[key] = String(baseDigit);  // first-time seed
    addressStr = nf[key];
  } else {
    addressStr = String(baseDigit);
  }

  label = `L${displayLayer}-O..` + addressStr;
}





    let speed = rot;
    if(!isSmall){
      if(nf.id === "ALPHA") speed = rot * 0.8;
      else if(nf.id === "BETA") speed = rot * 0.9;
      else if(nf.id === "OMEGA") speed = rot * 1.0;
      else if(nf.id === "DELTA") speed = rot * 1.1;
      else if(nf.id === "GAMMA") speed = rot * 1.2;
    } else {
      speed = rot * 0.8;
    }

    const spinInner = !(isLeft || isRight);
    const cx = baseX + dx;
    const cy = baseY + dy;

    // draw the nofur
    drawNofur(cx, cy, label, speed, scale, spinInner, isLeft, isRight);

    // record for click detection (with baseDigit)
nofurs.push({
  label,
  baseDigit,
  address: baseDigit !== null ? String(baseDigit) : "", // ← give each nofur its own address store
  center: { x: cx, y: cy },
  outerRadius: 100 * scale,
  flag: isLeft ? "left" : (isRight ? "right" : null)
});


    // Tag overlays (A1/B1/O1/... etc.)
    if(isSmall){
      ctx.fillStyle="white";
      ctx.font="16px monospace";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      const tags = isLeft ? {
        ALPHA:["A1","2"], BETA:["A2","3"], OMEGA:["O1","0"], DELTA:["D1","6"], GAMMA:["D2","7"]
      } : isRight ? {
        ALPHA:["B1","4"], BETA:["B2","5"], OMEGA:["O2","1"], DELTA:["G1","8"], GAMMA:["G2","9"]
      } : {};
      if(tags[nf.id]){
        const [tag1, tag2] = tags[nf.id];
        const offsetX = (nf.id==="BETA"||nf.id==="GAMMA"||(isRight && nf.id==="OMEGA")) ? -50 : 50;
        ctx.fillText(tag1, cx+offsetX, cy-15);
        ctx.fillText(tag2, cx+offsetX, cy+15);
      }
    }
  }
}

function drawTitle(){
  ctx.fillStyle="#0ff";
  ctx.font="24px monospace";
  ctx.textAlign="center";

  const currentLayer = (pyramidLayers - activeLayers) + 1;

  // Show omniverse as full address
  const addressDisplay = omniverseAddress === "" ? "0" : omniverseAddress;

  // Gasket display: first pass = "Gasket 1", next wraps = "Gasket 1^2", etc.
  const gasketLabel = gasketPower === 1
    ? `Gasket ${gasket}`
    : `Gasket ${gasket}^${gasketPower}`;

  ctx.fillText(
    `${gasketLabel} • Segment ${segment} • Layer ${currentLayer} • Omniverse ${addressDisplay}`,
    center.x,
    50
  );
}



function connectNofurs(parent, leftChild, rightChild) {
  ctx.save();
  ctx.strokeStyle = "#ff0000";
  ctx.lineWidth = 2;
  const startX = parent.x;
  const startY = parent.y + 100;
  const leftX = leftChild.x + 110;
  const leftY = leftChild.y;
  const rightX = rightChild.x - 110;
  const rightY = rightChild.y;
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(startX, leftY - 100);
  ctx.lineTo(leftX, leftY - 100);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(startX, startY);
  ctx.lineTo(startX, rightY - 100);
  ctx.lineTo(rightX, rightY - 100);
  ctx.stroke();
  ctx.restore();
}

// === Draw Sierpinski fractal inside a red box ===
function drawSierpinskiBox() {
  const boxWidth = 250;
  const boxHeight = 250;
  const boxX = center.x - boxWidth / 2;
  const boxY = center.y - 380; // positioned above the middle nofur

  // Outline box
  ctx.strokeStyle = "#ff0000";
  ctx.lineWidth = 2;
  ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

  // Recursive triangle fractal inside the box
  function drawSierpinski(x1, y1, x2, y2, x3, y3, depth) {
    if (depth <= 0) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x3, y3);
      ctx.closePath();
      ctx.stroke();
      return;
    }
    const mx1 = (x1 + x2) / 2, my1 = (y1 + y2) / 2;
    const mx2 = (x2 + x3) / 2, my2 = (y2 + y3) / 2;
    const mx3 = (x3 + x1) / 2, my3 = (y3 + y1) / 2;
    drawSierpinski(x1, y1, mx1, my1, mx3, my3, depth - 1);
    drawSierpinski(mx1, my1, x2, y2, mx2, my2, depth - 1);
    drawSierpinski(mx3, my3, mx2, my2, x3, y3, depth - 1);
  }

  // Define the base triangle inside the box
  const margin = 20;
  const x1 = boxX + margin;
  const y1 = boxY + boxHeight - margin;   // bottom-left
  const x2 = boxX + boxWidth - margin;
  const y2 = boxY + boxHeight - margin;   // bottom-right
  const x3 = boxX + boxWidth / 2;
  const y3 = boxY + margin;               // top

  ctx.strokeStyle = "#ff0000";
  drawSierpinski(x1, y1, x2, y2, x3, y3, 4);

  // === Green "segment position" line ===
  // Segment 1 = top of triangle, Segment 17 = bottom
  const maxSeg = pyramidLayers; // 17 in your current setup
  const segClamped = Math.max(1, Math.min(segment, maxSeg));
  const t = (segClamped - 1) / (maxSeg - 1); // 0 → top, 1 → bottom

  // Interpolate vertical position between top (y3) and bottom (y1)
  const yLine = y3 + t * (y1 - y3);

  // Find intersection with left and right edges of the triangle
  // Left edge: (x3,y3) → (x1,y1)
  // Right edge: (x3,y3) → (x2,y2)
  function interpX(xA, yA, xB, yB, y) {
    // linear interpolation along edge for a given y
    const ratio = (y - yA) / (yB - yA);
    return xA + ratio * (xB - xA);
  }

  const xLeft  = interpX(x3, y3, x1, y1, yLine);
  const xRight = interpX(x3, y3, x2, y2, yLine);

  ctx.strokeStyle = "#00ff00";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xLeft, yLine);
  ctx.lineTo(xRight, yLine);
  ctx.stroke();
}


// === Pyramid Stack System ===
let pyramidLayers = 17; // total layers
let activeLayers = 17;  // how many are still visible

function drawPyramidStack() {
  const centerX = center.x;
  const centerY = center.y + 245; // position above the main Nofur system
  const baseSize = 150;
  const layerStep = 5;

  for (let i = 0; i < activeLayers; i++) {
    const size = baseSize - i * layerStep;
    const half = size / 3;
    const color = `hsl(${(i * 40) % 360},100%,60%)`;

    ctx.save();
    ctx.translate(centerX, centerY-15);
    ctx.rotate(Math.PI / 4); // turn into a diamond orientation
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(-half, -half, size, size);
    ctx.restore();
  }

  // Outer red text box & labels
  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  const boxSize = baseSize + 5;
  const half = boxSize / 3;

  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(Math.PI / 4);
  ctx.strokeRect(-half-10, -half-10, boxSize, boxSize);
  ctx.restore();

  // draw control boxes with normal orientation
  const controlOffsetX = 90;
  const controlOffsetY = 100;

  ctx.strokeStyle = "red";
  ctx.lineWidth = 2;
  ctx.font = "12px monospace";
  ctx.textAlign = "center";
  ctx.fillStyle = "red";

  // LEFT
  ctx.strokeRect(centerX - controlOffsetX - 25, centerY - controlOffsetY, 50, 30);
  ctx.fillText("RESET", centerX - controlOffsetX, centerY - controlOffsetY + 10);
  ctx.fillText("SYSTEM", centerX - controlOffsetX, centerY - controlOffsetY + 20);

  // RIGHT
  ctx.strokeRect(centerX + controlOffsetX - 25, centerY - controlOffsetY, 50, 30);
  ctx.fillText("RETURN", centerX + controlOffsetX, centerY - controlOffsetY + 10);
  ctx.fillText("HOME", centerX + controlOffsetX, centerY - controlOffsetY + 20);

  // LOWER LEFT
  ctx.strokeRect(centerX - controlOffsetX - 50, centerY + controlOffsetY, 100, 20);
  ctx.fillText("LAYER UP", centerX - controlOffsetX, centerY + controlOffsetY + 10);

  // LOWER RIGHT
  ctx.strokeRect(centerX + controlOffsetX - 50, centerY + controlOffsetY, 100, 20);
  ctx.fillText("TOP LAYER", centerX + controlOffsetX, centerY + controlOffsetY + 10);

  // Layer label
  ctx.fillStyle = "cyan";
  ctx.font = "20px monospace";

  // Compute current layer index: starts at 1 and increases as layers peel off
  const currentLayer = (pyramidLayers - activeLayers) + 1;

  ctx.fillText(`Layer ${currentLayer}`, centerX, centerY - 95);
}

let rot=0;
function animate(){
  ctx.clearRect(0,0,W,H);
  seekerPositions = [];
  //nofurs = [];            // reset nofurs each frame
nofurs = [];
window.nofurs = nofurs;

  rot+=0.01;
  drawTitle();
  drawSierpinskiBox();
  drawPyramidStack();

  const alphaTop = { x: center.x - 300, y: center.y - 235 };
  const leftBelow = { x: alphaTop.x - 175, y: alphaTop.y + 250 };
  const rightBelow = { x: alphaTop.x + 175, y: alphaTop.y + 250 };
  connectNofurs(alphaTop, leftBelow, rightBelow);

  const betaTop = { x: center.x + 300, y: center.y - 235 };
  const betaLeft = { x: betaTop.x - 175, y: betaTop.y + 250 };
  const betaRight = { x: betaTop.x + 175, y: betaTop.y + 250 };
  connectNofurs(betaTop, betaLeft, betaRight);

  const gammaTop = { x: center.x - 300, y: center.y + 40 };
  const gammaLeft = { x: gammaTop.x - 175, y: gammaTop.y + 150 };
  const gammaRight = { x: gammaTop.x + 175, y: gammaTop.y + 150 };
  connectNofurs(gammaTop, gammaLeft, gammaRight);

  const deltaTop = { x: center.x + 300, y: center.y + 40 };
  const deltaLeft = { x: deltaTop.x - 175, y: deltaTop.y + 150 };
  const deltaRight = { x: deltaTop.x + 175, y: deltaTop.y + 150 };
  connectNofurs(deltaTop, deltaLeft, deltaRight);

  const omegaCenter = { x: center.x, y: center.y };
  const outerRadius = 110;
  const omegaLeftEdge  = { x: omegaCenter.x - outerRadius, y: omegaCenter.y };
  const omegaRightEdge = { x: omegaCenter.x + outerRadius, y: omegaCenter.y };
  const omegaLeftTarget  = { x: omegaLeftEdge.x - 175, y: omegaLeftEdge.y };
  const omegaRightTarget = { x: omegaRightEdge.x + 175, y: omegaRightEdge.y };
  ctx.strokeStyle = "#FF0000";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(omegaLeftEdge.x, omegaLeftEdge.y);
  ctx.lineTo(omegaLeftTarget.x+25, omegaLeftTarget.y);
  ctx.moveTo(omegaRightEdge.x, omegaRightEdge.y);
  ctx.lineTo(omegaRightTarget.x-25, omegaRightTarget.y);
  ctx.stroke();

  drawOmniverse(center.x, center.y, rot, 1.0);
  drawOmniverse(center.x-300, center.y, rot, 0.35, true, true, false);
  drawOmniverse(center.x+300, center.y, rot, 0.35, true, false, true);

  // === Connect each non-OMEGA seeker to nearest OMEGA seeker ===
  const omegaSeekers = seekerPositions.filter(s => s.label === "OMEGA");
  const otherSeekers = seekerPositions.filter(s => s.label !== "OMEGA");

  function blendColors(c1, c2) {
    const hex = x => parseInt(x.slice(1),16);
    const r1=(hex(c1)>>16)&255,g1=(hex(c1)>>8)&255,b1=hex(c1)&255;
    const r2=(hex(c2)>>16)&255,g2=(hex(c2)>>8)&255,b2=hex(c2)&255;
    const r=Math.floor((r1+r2)/2),g=Math.floor((g1+g2)/2),b=Math.floor((b1+b2)/2);
    return `rgb(${r},${g},${b})`;
  }

  ctx.lineWidth = 2;
  for(let s of otherSeekers){
    let nearest = null;
    let nearestDist = Infinity;
    for(let o of omegaSeekers){
      const dx = o.x - s.x;
      const dy = o.y - s.y;
      const d2 = dx*dx+dy*dy;
      if(d2 < nearestDist){nearestDist=d2;nearest=o;}
    }
    if(nearest){
      ctx.strokeStyle = blendColors(s.color, nearest.color);
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(nearest.x, nearest.y);
      ctx.stroke();
    }
  }

  requestAnimationFrame(animate);
}

animate();

document.getElementById("layoutBtn").addEventListener("click",()=>{ compact = !compact; });
</script>
<script src="meq-eyeball.js"></script>
<script src="meq-tv-videos.js"></script>
<script src="meq-chat.js"></script>
<script src="meq-room-chat.js"></script>
<script src="meq-music.js"></script>
<script src="meq-slash-commands.js"></script>
<script src="meq-skybox-toggle.js"></script>
<script src="meq-tv.js"></script>
<script src="meq-toolkit.js"></script>
<script src="meq-boom.js"></script>
<script src="meq-nofur-lock.js"></script>
<script src="meq-helper.js"></script>
<script src="meq-ads.js"></script>
<script src="meq-tone-engine.js"></script>
<script type="module" src="meq-eve-mouth.js"></script>
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">



</script>


<script type="module" src="meq-eve-overlay.js"></script>
<script>
  window.EVE_SCALE = 130;   // try 40, 80, 150, 300
</script>

</body>
</html>
